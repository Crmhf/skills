# 系统设计工作流程

标准化的系统设计流程，确保设计质量和一致性。

---

## 1. 需求分析阶段

### 功能需求收集
```
业务需求 → 功能列表 → 优先级排序 → MVP定义
```

### 非功能需求识别

| 维度 | 关键指标 | 问题清单 |
|-----|---------|---------|
| 性能 | QPS、延迟、吞吐量 | 峰值流量是多少？响应时间要求？ |
| 可用性 | SLA、RTO、RPO | 允许停机时间？数据丢失容忍度？ |
| 可扩展性 | 数据增长、用户增长 | 1年后规模？5年后规模？ |
| 安全性 | 认证、授权、审计 | 敏感数据？合规要求？ |
| 可维护性 | 部署频率、回滚时间 | 发布周期？故障恢复时间？ |

### 流量预估公式
```
日活用户(DAU) × 日均访问次数 × 峰值系数(2-3) = 日请求量
日请求量 ÷ 86400秒 × 80/20法则 = 峰值QPS
```

---

## 2. 高层设计阶段

### 架构风格选择

决策树：
```
团队规模 < 10人?
  是 → 单体架构
  否 → 业务复杂度高?
         是 → 微服务架构
         否 → 模块化单体
```

### 核心组件设计

```
┌─────────────────────────────────────────┐
│                 CDN                     │
└─────────────────────────────────────────┘
                   │
┌─────────────────────────────────────────┐
│              负载均衡器                  │
│            (Nginx/ALB)                  │
└─────────────────────────────────────────┘
                   │
┌─────────────────────────────────────────┐
│              API 网关                   │
│      (认证/限流/路由/监控)              │
└─────────────────────────────────────────┘
                   │
┌──────────┬───────┴───────┬──────────────┐
│          │               │              │
│  服务A   │    服务B      │    服务C     │
│          │               │              │
└────┬─────┴───────────────┴──────┬───────┘
     │                            │
┌────┴──────┐              ┌──────┴──────┐
│   缓存    │              │   数据库    │
│ (Redis)   │              │  (MySQL)    │
└───────────┘              └─────────────┘
```

---

## 3. 详细设计阶段

### API 设计规范

**RESTful API:**
```
GET    /api/v1/users           # 列表查询
GET    /api/v1/users/{id}      # 详情查询
POST   /api/v1/users           # 创建资源
PUT    /api/v1/users/{id}      # 全量更新
PATCH  /api/v1/users/{id}      # 部分更新
DELETE /api/v1/users/{id}      # 删除资源
```

**响应格式:**
```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "pagination": {
    "page": 1,
    "size": 20,
    "total": 100
  }
}
```

### 数据库设计流程

```
需求分析 → 概念设计(E-R图) → 逻辑设计(表结构) → 物理设计(索引/分区) → 评审优化
```

**设计原则:**
1. 第三范式为基础，必要时反规范化
2. 主键使用自增ID或雪花ID
3. 外键在应用层维护，数据库不加外键约束
4. 索引设计覆盖常用查询
5. 大表考虑分区分片

### 缓存设计策略

| 策略 | 适用场景 | 注意事项 |
|-----|---------|---------|
| Cache-Aside | 读多写少 | 缓存穿透、击穿、雪崩 |
| Read-Through | 简化代码 | 需要缓存库支持 |
| Write-Through | 强一致性 | 写性能下降 |
| Write-Behind | 高吞吐 | 数据丢失风险 |

---

## 4. 非功能性设计

### 高可用设计

**多可用区部署:**
```
        ┌──────────────┐
        │   流量入口    │
        │  (GTM/DNS)   │
        └──────┬───────┘
               │
    ┌──────────┼──────────┐
    ▼          ▼          ▼
┌───────┐  ┌───────┐  ┌───────┐
│ AZ-A  │  │ AZ-B  │  │ AZ-C  │
│ 主    │  │ 备    │  │ 备    │
└───────┘  └───────┘  └───────┘
```

**故障转移机制:**
- 数据库：主从切换（自动/手动）
- 服务：健康检查 + 自动剔除
- 缓存：集群模式 + 哨兵监控

### 安全防护设计

**分层防护:**
```
边界层: WAF + DDoS防护
├── 接入层: HTTPS + 证书管理
├── 网关层: 认证 + 鉴权 + 限流
├── 服务层: 输入校验 + SQL注入防护
└── 数据层: 加密存储 + 审计日志
```

---

## 5. 设计评审检查清单

### 架构评审
- [ ] 架构图是否完整清晰
- [ ] 组件职责是否单一
- [ ] 依赖关系是否合理
- [ ] 扩展性是否满足未来增长
- [ ] 是否存在单点故障

### 性能评审
- [ ] QPS 预估是否准确
- [ ] 缓存策略是否合理
- [ ] 数据库索引是否覆盖主要查询
- [ ] 是否存在 N+1 查询
- [ ] 慢查询是否有优化方案

### 安全评审
- [ ] 敏感数据是否加密
- [ ] 接口是否有权限控制
- [ ] 输入是否做了校验和过滤
- [ ] 是否有防重放攻击机制
- [ ] 日志是否脱敏

### 运维评审
- [ ] 是否有健康检查接口
- [ ] 是否有监控指标
- [ ] 部署方案是否平滑
- [ ] 回滚方案是否可行
- [ ] 故障处理手册是否完善

---

## 6. 设计文档模板

```markdown
# XX系统设计文档

## 1. 背景与目标
- 业务背景
- 设计目标
- 成功指标

## 2. 需求分析
### 2.1 功能需求
### 2.2 非功能需求
- 性能指标
- 可用性指标
- 安全要求

## 3. 架构设计
### 3.1 总体架构
### 3.2 核心流程
### 3.3 模块划分

## 4. 详细设计
### 4.1 数据模型
### 4.2 API 设计
### 4.3 状态机
### 4.4 算法逻辑

## 5. 非功能性设计
### 5.1 高可用
### 5.2 性能优化
### 5.3 安全防护
### 5.4 监控告警

## 6. 部署方案
### 6.1 环境规划
### 6.2 发布流程
### 6.3 回滚方案

## 7. 风险评估
### 7.1 技术风险
### 7.2 应对措施

## 8. 附录
### 8.1 术语表
### 8.2 参考资料
```
