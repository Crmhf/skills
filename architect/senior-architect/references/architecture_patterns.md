# 架构模式大全

本指南涵盖常用的软件架构模式，帮助架构师选择合适的架构风格。

---

## 1. 分层架构 (Layered Architecture)

### 概述
将应用划分为多个水平层，每层有明确的职责。

```
┌─────────────────┐
│   表示层 (UI)   │
├─────────────────┤
│   业务逻辑层    │
├─────────────────┤
│   数据访问层    │
├─────────────────┤
│   数据库层      │
└─────────────────┘
```

### 适用场景
- 传统 Web 应用
- 中小型项目
- 团队技术栈统一

### 优点
- 简单易懂
- 分工明确
- 易于测试

### 缺点
- 层间调用开销
- 容易导致贫血模型

---

## 2. 微服务架构 (Microservices)

### 概述
将应用拆分为一组小型的、独立部署的服务。

```
┌─────────┐ ┌─────────┐ ┌─────────┐
│ 用户服务 │ │ 订单服务 │ │ 库存服务 │
└────┬────┘ └────┬────┘ └────┬────┘
     │           │           │
     └───────────┴───────────┘
                 │
          ┌──────┴──────┐
          │   API 网关   │
          └─────────────┘
```

### 适用场景
- 大型复杂系统
- 团队规模 > 20人
- 需要独立部署和扩展

### 优点
- 独立部署
- 技术栈灵活
- 故障隔离

### 缺点
- 分布式复杂性
- 运维成本高
- 数据一致性挑战

### 拆分原则
1. **按业务能力拆分** - 用户、订单、支付
2. **按领域驱动设计** - 限界上下文
3. **数据库独立** - 每个服务拥有自己的数据

---

## 3. 事件驱动架构 (Event-Driven)

### 概述
系统组件通过事件进行异步通信。

```
┌─────────┐     ┌─────────┐     ┌─────────┐
│ 事件源  │────▶│ 消息队列 │────▶│ 事件处理器│
└─────────┘     └─────────┘     └─────────┘
                                      │
                    ┌─────────────────┼─────────────────┐
                    ▼                 ▼                 ▼
              ┌─────────┐      ┌─────────┐      ┌─────────┐
              │ 处理器A │      │ 处理器B │      │ 处理器C │
              └─────────┘      └─────────┘      └─────────┘
```

### 事件模式

#### 事件通知
仅通知事件已发生，消费者需查询详情。

```json
{
  "eventType": "OrderCreated",
  "orderId": "ORD-12345",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

#### 事件携带状态转移
事件包含完整状态信息。

```json
{
  "eventType": "OrderCreated",
  "order": {
    "id": "ORD-12345",
    "userId": "USR-001",
    "amount": 199.99,
    "items": [...]
  }
}
```

### 适用场景
- 高并发削峰
- 异步处理
- 系统解耦
- 实时数据处理

---

## 4. CQRS (命令查询职责分离)

### 概述
将读操作和写操作分离到不同的模型。

```
         ┌──────────────┐
         │   客户端      │
         └──────┬───────┘
                │
       ┌────────┴────────┐
       ▼                 ▼
┌─────────────┐   ┌─────────────┐
│   命令端    │   │    查询端   │
│  (写模型)   │   │   (读模型)  │
└──────┬──────┘   └──────┬──────┘
       │                 │
       ▼                 ▼
┌─────────────┐   ┌─────────────┐
│  写数据库   │   │   读数据库  │
│  (规范化)   │   │  (非规范化) │
└─────────────┘   └─────────────┘
```

### 适用场景
- 读多写少
- 复杂的查询需求
- 需要高性能读取

### 数据同步
- 事件溯源
- 数据库触发器
- 消息队列

---

## 5. 六边形架构 (Hexagonal Architecture)

### 概述
也称为端口与适配器模式，将业务逻辑与外部依赖隔离。

```
                    ┌───────────┐
                    │   Web API │
                    └─────┬─────┘
                          │
    ┌───────────┐   ┌─────┴─────┐   ┌───────────┐
    │  CLI 工具 │   │           │   │  消息队列 │
    └─────┬─────┘   │  业务核心 │   └─────┬─────┘
          │         │           │         │
    ┌─────┴─────┐   │ ┌───────┐ │   ┌─────┴─────┐
    │  适配器   │   │ │领域逻辑│ │   │  适配器   │
    └───────────┘   │ └───────┘ │   └───────────┘
                    └─────┬─────┘
                          │
                    ┌─────┴─────┐
                    │  数据库   │
                    └───────────┘
```

### 核心概念
- **端口 (Ports)**：定义接口契约
- **适配器 (Adapters)**：实现具体技术

### 适用场景
- 需要长期演进的核心系统
- 测试驱动开发
- 技术栈可能更换

---

## 6. 整洁架构 (Clean Architecture)

### 概述
Robert C. Martin 提出的架构理念，依赖关系向内指向核心业务。

```
       ┌──────────────────────────┐
       │     外部框架/驱动层       │
       │  (UI, DB, Web, Devices) │
       ├──────────────────────────┤
       │      接口适配层          │
       │  (Controllers, Gateways) │
       ├──────────────────────────┤
       │      用例层              │
       │  (应用业务规则)          │
       ├──────────────────────────┤
       │      实体层              │
       │  (核心业务规则)          │
       └──────────────────────────┘
```

### 依赖规则
内层不依赖外层，依赖关系始终向内。

### 目录结构示例
```
src/
├── domain/          # 实体层
│   ├── entities/
│   └── value-objects/
├── usecases/        # 用例层
│   ├── ports/
│   └── services/
├── adapters/        # 适配器层
│   ├── web/
│   ├── persistence/
│   └── messaging/
└── infrastructure/  # 框架层
    ├── config/
    └── external/
```

---

## 7. Saga 模式

### 概述
用于处理分布式事务，通过一系列本地事务和补偿操作保证最终一致性。

### 编排式 Saga
```
订单服务 → 库存服务 → 支付服务
   ↓         ↓         ↓
创建订单   扣减库存   扣减余额
   │         │         │
   └─────────┴─────────┘
           │
      订单完成/回滚
```

### 编舞式 Saga
每个服务完成本地事务后发送事件，触发下一个服务。

```
订单服务 ──创建订单──▶ 发送Event
                              │
                              ▼
                        库存服务 ──扣减库存──▶ 发送Event
                                                       │
                                                       ▼
                                                 支付服务
```

### 适用场景
- 跨服务事务
- 长事务处理
- 最终一致性要求

---

## 8. 数据库选型决策矩阵

| 场景 | 推荐方案 | 备选方案 |
|------|---------|---------|
| 通用事务型 | PostgreSQL | MySQL |
| 高并发缓存 | Redis | Memcached |
| 全文搜索 | Elasticsearch | Meilisearch |
| 时序数据 | InfluxDB | TimescaleDB |
| 图数据 | Neo4j | Dgraph |
| 文档存储 | MongoDB | Couchbase |
| 列式存储 | ClickHouse | Apache Druid |

---

## 9. 架构演进路线图

### 阶段1: 单体应用
- 快速迭代
- 验证产品
- 团队 < 10人

### 阶段2: 垂直拆分
- 按业务能力拆分
- 共享数据库
- 引入 API 网关

### 阶段3: 微服务化
- 服务独立数据库
- 引入服务网格
- 完善 DevOps

### 阶段4: 云原生
- 容器化部署
- 弹性伸缩
- 多活架构
