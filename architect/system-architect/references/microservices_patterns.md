# 微服务架构模式大全

微服务架构设计模式汇总，涵盖服务拆分、通信、数据管理等关键场景。

---

## 1. 服务拆分模式

### 按业务能力拆分 (Decompose by Business Capability)

根据业务领域划分服务，每个服务负责一个完整的业务能力。

**适用场景:** 业务边界清晰的系统

**示例:**
```
电商系统:
- 用户服务 (User Service)
- 商品服务 (Product Service)
- 订单服务 (Order Service)
- 库存服务 (Inventory Service)
- 支付服务 (Payment Service)
```

### 按子域拆分 (Decompose by Subdomain)

基于领域驱动设计(DDD)的限界上下文进行拆分。

**分层结构:**
```
核心域 (Core Domain) → 订单处理、支付结算
支撑域 (Supporting Domain) → 用户管理、商品管理
通用域 (Generic Domain) → 通知服务、文件存储
```

---

## 2. 服务通信模式

### 同步通信

**REST API**
- 优点: 简单、通用、易于调试
- 缺点: 强耦合、级联故障风险
- 适用: 查询类操作、实时性要求高

**gRPC**
- 优点: 高性能、强类型、流式支持
- 缺点: 浏览器支持有限、需要proto定义
- 适用: 服务间内部通信

### 异步通信

**消息队列 (Message Queue)**
```
服务A → 消息队列 → 服务B、服务C
```
- 削峰填谷
- 最终一致性
- 解耦生产者和消费者

**事件总线 (Event Bus)**
```
订单创建事件 → 库存服务(扣减)
              → 物流服务(创建运单)
              → 通知服务(发送短信)
```

---

## 3. 数据管理模式

### 数据库 per 服务

每个服务拥有独立的数据库，保证服务自治。

```
用户服务 ↔ 用户数据库(MySQL)
订单服务 ↔ 订单数据库(MySQL)
商品服务 ↔ 商品数据库(MongoDB)
```

### Saga 模式 (分布式事务)

**编排式 Saga (Orchestration)**
```
订单协调器 → 调用库存服务 → 调用支付服务 → 调用物流服务
                ↓失败           ↓失败           ↓失败
            回滚库存        退款            取消运单
```

**协作式 Saga (Choreography)**
```
订单服务 → 发布"订单创建"事件
库存服务 ← 订阅并扣减库存 → 发布"库存已扣"事件
支付服务 ← 订阅并处理支付 → 发布"支付完成"事件
```

### CQRS 模式 (命令查询职责分离)

```
写操作 → 命令处理器 → 写数据库(MySQL)
                         ↓ 同步
读操作 ← 查询处理器 ← 读数据库(Elasticsearch/Redis)
```

---

## 4. 容错模式

### 熔断器 (Circuit Breaker)

```
CLOSED → OPEN → HALF_OPEN
 正常    熔断    探测恢复
```

**配置参数:**
- 失败阈值: 5次/10秒
- 熔断持续时间: 30秒
- 半开请求数: 3次

### 舱壁隔离 (Bulkhead)

限制每个服务或接口的资源使用，防止故障扩散。

```
线程池隔离:
- 订单接口: 最大50线程
- 查询接口: 最大100线程
- 管理接口: 最大20线程
```

### 重试与退避

**指数退避策略:**
```
第1次重试: 1秒后
第2次重试: 2秒后
第3次重试: 4秒后
第4次重试: 8秒后 (不超过最大间隔)
```

---

## 5. 网关模式

### API 网关

**核心功能:**
- 路由转发
- 认证鉴权
- 限流熔断
- 协议转换
- 日志监控

**架构图:**
```
客户端 → API网关 → 用户服务
                 → 订单服务
                 → 商品服务
```

### BFF (Backend for Frontend)

为不同客户端提供定制化 API:
```
移动端APP → 移动BFF → 聚合服务
Web端     → Web BFF → 聚合服务
管理后台  → Admin BFF → 聚合服务
```

---

## 6. 服务发现模式

### 客户端发现

```
服务消费者 → 注册中心(Consul/Eureka) → 获取服务列表 → 直接调用
```

### 服务端发现

```
服务消费者 → 负载均衡器(Nginx/ALB) → 转发到具体实例
                     ↑
               注册中心同步
```

---

## 7. 部署模式

### 单主机多服务

适合开发环境或小型系统。

### 单容器单服务

```
Docker容器 → 服务实例
```

### 单 Pod 多容器 (Sidecar)

```
Pod:
  - 业务容器 (主服务)
  - Sidecar容器 (日志收集、监控代理)
```

### Serverless 部署

```
函数代码 → 云平台(Lambda/Function Compute) → 按需执行
```

---

## 模式选择决策树

```
是否需要强一致性?
├─ 是 → 使用同步调用 + 分布式事务(Saga/TCC)
└─ 否 → 使用异步消息

是否需要实时响应?
├─ 是 → 同步调用(REST/gRPC)
└─ 否 → 消息队列

数据查询复杂吗?
├─ 是 → 考虑 CQRS
└─ 否 → 统一模型

是否有级联故障风险?
├─ 是 → 熔断器 + 舱壁隔离
└─ 否 → 直接调用
```
